# -*- coding: utf-8 -*-
"""new.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FJLIR2WM0iChyACxoML6YthJfDJassj3
"""

# Install necessary libraries
!pip install pandas numpy scikit-learn matplotlib seaborn xgboost shap

# Import libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score, roc_curve
import shap
import warnings
warnings.filterwarnings('ignore')

# Load sample opioid dataset (simulated)
url = "https://raw.githubusercontent.com/plotly/datasets/master/diabetes.csv"  # Placeholder
df = pd.read_csv(url)

# Display first 5 rows
df.head()

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(7,5))

# Boxplot for Glucose vs Outcome
sns.boxplot(x='Outcome', y='Glucose', data=df, palette='coolwarm')

plt.title('Distribution of Glucose Levels by Opioid Overdose Risk')
plt.xlabel('Outcome (0 = No Risk, 1 = High Risk)')
plt.ylabel('Glucose Level')
plt.grid(axis='y')
plt.show()

# Check for null values
print(df.isnull().sum())

# Feature selection (drop columns if required)
# For now, we will use all columns

# Define Features and Target
X = df.drop('Outcome', axis=1)   # Features
y = df['Outcome']                # Target variable (High Risk = 1, Low Risk = 0)

# Train-Test Split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Feature Scaling
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Correlation Heatmap
plt.figure(figsize=(10,7))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm')
plt.title("Feature Correlation Heatmap")
plt.show()

# Bar Plot for Glucose Distribution
plt.figure(figsize=(7,5))
sns.histplot(df['Glucose'], bins=20, kde=True)
plt.title('Glucose Level Distribution among Patients')
plt.xlabel('Glucose')
plt.ylabel('Count')
plt.show()

# Bar Plot for Age Distribution
plt.figure(figsize=(7,5))
sns.histplot(df['Age'], bins=20, kde=True, color='orange')
plt.title('Age Distribution among Patients')
plt.xlabel('Age')
plt.ylabel('Count')
plt.show()

# SHAP Analysis for Model Interpretability

# SHAP Analysis for Model Interpretability
explainer = shap.TreeExplainer(model)

# Generate SHAP values on original (unscaled) test data
shap_values = explainer.shap_values(X_test)

# SHAP Summary Plot
shap.summary_plot(shap_values, X_test, feature_names=X.columns)

# SHAP Dependence Plot (Example: Glucose Feature)
shap.dependence_plot('Glucose', shap_values, X_test, feature_names=X.columns)

# Initialize and Train Model
model = GradientBoostingClassifier()
model.fit(X_train, y_train)

# Predict
y_pred = model.predict(X_test)

# Classification Report
print(classification_report(y_test, y_pred))

# Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.title("Confusion Matrix")
plt.show()

# ROC-AUC Score
roc_auc = roc_auc_score(y_test, model.predict_proba(X_test)[:,1])
print("ROC-AUC Score:", roc_auc)

# Initialize SHAP TreeExplainer with additivity check disabled
explainer = shap.TreeExplainer(model, feature_perturbation="interventional")

# Calculate SHAP values
shap_values = explainer.shap_values(X_test)

# Plot Feature Importance
shap.summary_plot(shap_values, X_test, feature_names=X.columns)

# SHAP Force Plot (Static Image for Google Colab)

# Prepare the data for a single prediction (e.g., index 0)
index = 0

# Create a Matplotlib force plot (works in Colab)
shap.plots.waterfall(shap.Explanation(values=shap_values[index],
                                      base_values=explainer.expected_value,
                                      data=X_test[index],
                                      feature_names=X.columns))

# Policy Recommendations based on SHAP Results

print("Policy Recommendations for Opioid Overdose Prevention:\n")

print("1. Age-Based Monitoring:")
print("   - Patients above age threshold (e.g., 50+) require frequent checkups & counseling.")

print("2. High Glucose & Insulin Level Patients:")
print("   - Monitor blood sugar control in opioid prescribed patients.")
print("   - Encourage diabetic management programs.")

print("3. BMI & Obesity Factors:")
print("   - Lifestyle interventions for high BMI patients.")

print("4. Personalized Healthcare:")
print("   - Use model explainability (SHAP) to provide patient-specific alerts.")

print("5. Data-Informed Policy Making:")
print("   - Government & hospitals should analyze patient clusters from model results.")
print("   - Allocate resources for high-risk zones or demographics.")

print("6. Ethical Usage:")
print("   - Ensure patient privacy & ethical data handling while deploying AI models.")

print("\nThese are machine-learning-driven recommendations for better opioid overdose prevention strategy.")

import joblib

# Save Model
joblib.dump(model, 'opioid_overdose_model.pkl')

# Save Scaler
joblib.dump(scaler, 'scaler.pkl')

print("Model and Scaler saved successfully!")

from google.colab import files

# Download Model
files.download('opioid_overdose_model.pkl')

# Download Scaler
files.download('scaler.pkl')

import numpy as np

# New Patient Data
new_patient = np.array([[45, 150, 85, 28.5, 0.351, 30, 80, 2]])

# Scale new patient data
new_patient_scaled = scaler.transform(new_patient)

# Predict
risk = model.predict(new_patient_scaled)

if risk[0] == 1:
    print("High Risk of Opioid Overdose!")
else:
    print("Low Risk of Opioid Overdose.")

from sklearn.metrics import roc_curve, auc

# Predict probabilities
y_proba = model.predict_proba(X_test)[:,1]

# Calculate ROC curve
fpr, tpr, thresholds = roc_curve(y_test, y_proba)
roc_auc = auc(fpr, tpr)

plt.figure(figsize=(6,4))
plt.plot(fpr, tpr, color='darkorange', lw=2, label='AUC = %0.2f' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()